/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  5                                     |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

scale 1;


L #eval #{5/3#}; //  #5/3 5/4 5/5 5/6 5/7 //must be a whole period compared to the length of the channel.
a 0.08; // #0.08 0.06 0.04 0.02 // In meter.
phi 75; //in degrees 0->360
    
cell_x 112;
cell_y 560;
cell_z 1;

channel_depth 0.1;
channel_length 5; 
channel_width 1; 

fix #eval #{$a*sin((0+($L)/4)*degToRad(180)*(2/($L)))#};
fix2 #eval #{$channel_width+$a*sin((($channel_length+($L)/4)*degToRad(180)*(2/($L)))+degToRad($phi))#};


vertices
(
    //block1
    ($fix 0 0) 								//0
    ($fix2 0 0)  							//1
    ($fix $channel_length 0) 				//2
    ($fix2 $channel_length 0) 				//3
    ($fix 0 $channel_depth) 				//4
    ($fix2 0 $channel_depth) 				//5
    ($fix $channel_length $channel_depth) 	//6
    ($fix2 $channel_length $channel_depth) 	//7
    
);

blocks
(
    //block1
    hex (0 1 3 2 4 5 7 6) ($cell_x $cell_y $cell_z) simpleGrading (
        1
        1 
        1
    )  
);

edges
(
    spline 0 2
	#codeStream 
	{
    codeInclude
    #{
        #include "pointField.H"
    #};

    code
    #{
        pointField points(120);
		double length = $channel_length;
		double amp = $a;
		double period = $L;
		double sz = points.size();
		double thisy = length/sz;
		double step = 0;
		
		for (label i = 0; i < sz; i++)
        {
			step = i*thisy;
			points[i] = point(amp*sin((step+(period)/4)*degToRad(180)*(2/(period))), step, 0);

        }

        os  << points;
    #};
	}

    
    spline 4 6
	#codeStream 
	{
    codeInclude
    #{
        #include "pointField.H"
    #};

    code
    #{
        pointField points(120);
		double length = $channel_length;
		double amp = $a;
		double period = $L;
		double sz = points.size();
		double thisy = length/sz;
		double step = 0;
		
		for (label i = 0; i < sz; i++)
        {
			step = i*thisy;
			points[i] = point(amp*sin((step+(period)/4)*degToRad(180)*(2/(period))), step, $channel_depth);
			
        }

        os  << points;
    #};
	}
    
    spline 1 3
	#codeStream 
	{
    codeInclude
    #{
        #include "pointField.H"
    #};

    code
    #{
        pointField points(120);
		double length = $channel_length;
		double width = $channel_width;
		double phaseShift = $phi;
		double amp = $a;
		double period = $L;
		double sz = points.size();
		double thisy = length/sz;
		double step = 0;
		
		for (label i = 0; i < sz; i++)
        {
			step = i*thisy;
			points[i] = point((amp*sin(((step+(period)/4)*degToRad(180)*(2/(period)))+degToRad(phaseShift)))+width, step, 0);
			
        }
		
        os  << points;
    #};
	}

    spline 5 7
	#codeStream 
	{
    codeInclude
    #{
        #include "pointField.H"
    #};

    code
    #{
        pointField points(120);
		double length = $channel_length;
		double width = $channel_width;
		double phaseShift = $phi;
		double amp = $a;
		double period = $L;
		double sz = points.size();
		double thisy = length/sz;
		double step = 0;
		
		for (label i = 0; i < sz; i++)
        {
			step = i*thisy;
			points[i] = point((amp*sin(((step+(period)/4)*degToRad(180)*(2/(period)))+degToRad(phaseShift)))+width, step, $channel_depth);
			
        }

        os  << points;
    #};
	}
);

boundary
(
    bottom
    {
        type cyclic;
		neighbourPatch top;
        faces
        (
            (1 5 4 0)
        );
    }
	
    top
    {
        type cyclic;
		neighbourPatch bottom;
        faces
        (
            //Hvis block1
            (7 3 2 6)
        );
    }
	
    walls
    {
		type wall;
        faces
        (
	        (4 6 2 0)
            (5 1 3 7)
		);
	}

    
    frontAndBack
    {
        type empty;
        faces
        (
            (0 2 3 1)
            (4 5 7 6)

        );
    }
);

// mergePatchPairs
// (
// );

// ************************************************************************* //
